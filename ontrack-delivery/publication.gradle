/**
 * PUBLICATION OF A PACKAGE IN GITHUB
 *
 * See the Wiki at https://github.com/nemerosa/ontrack/wiki/Delivery
 */

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    }
}

import groovyx.net.http.ContentType
import groovyx.net.http.HTTPBuilder
import groovyx.net.http.Method

/**
 * Checking the required properties
 */

def param(String name) {
    if (!hasProperty(name)) throw new GradleException("${name} property must be set.")
    else return properties[name]
}

String githubToken() { param('githubToken') }

String ontrackVersion() { param('ontrackVersion') }

String ontrackBuild() { param('ontrackBuild') }

String ontrackCommit() { param('ontrackCommit') }

String ontrackBranch() { param('ontrackBranch') }

String ontrackUserName() { param('ontrackUserName') }

String ontrackUserPassword() { param('ontrackUserPassword') }

String releasePath() { param('releasePath') }

/**
 * Optional properties
 */

if (!hasProperty('ontrackUrl')) ext { ontrackUrl = 'https://ontrack.nemerosa.net' }
if (!hasProperty('ontrackProject')) ext { ontrackProject = 'ontrack' }
if (!hasProperty('githubRepository')) ext { githubRepository = 'nemerosa/ontrack' }

/**
 * Creating a GitHub release
 */
task githubReleaseCreate << {
    def url = "https://api.github.com/repos/${githubRepository}/releases"
    def http = new HTTPBuilder(url)
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = "token ${githubToken()}"
        headers['User-Agent'] = "${githubRepository}"
        body = [
                tag_name        : "${ontrackVersion()}".toString(),
                target_commitish: "${ontrackCommit()}".toString(),
                name            : "${ontrackVersion()}".toString(),
                prerelease      : true
        ]
        response.success = { resp, json ->
            int id = json.id as int
            println "Release ${ontrackVersion()} created with ID = $id"
            project.tasks.githubReleaseCreate.ext.releaseId = id
        }
    }
}

def uploadAsset(File file, String name, int releaseId, String githubToken) {
    println "Publishing ${file} as ${name}..."
    def url = "https://uploads.github.com/repos/${githubRepository}/releases/${releaseId}/assets?name=${name}"
    def http = new HTTPBuilder(url)
    http.ignoreSSLIssues()
    http.request(Method.POST) { req ->
        headers['Authorization'] = "token ${githubToken}"
        headers['User-Agent'] = "${githubRepository}"
        headers['Content-Type'] = 'application/zip'
        send ContentType.BINARY, file.bytes
    }
}

task upload << {
    uploadAsset(
            new File('README.md'),
            'README.md',
            705274,
            '7b035624ad59866d34a6e83cd0c09decacb527be'
    )
}

/**
 * Uploading assets to a GitHub release
 */
task githubReleaseAssets(dependsOn: 'githubReleaseCreate') << {
    int id = project.tasks.githubReleaseCreate.releaseId
    // ['ontrack-ui', 'ontrack-acceptance', 'ontrack-delivery-docker'].each { name ->
    ['ontrack-ui'].each { name ->
        File file = new File(releasePath() as String, "${name}-${ontrackVersion()}.jar")
        println "Publishing ${file} to release ${ontrackVersion()} ($id)..."
        if (!file.exists()) {
            throw new GradleException("File ${file} cannot be published because it does not exist.")
        } else {
            uploadAsset file, "${name}.jar", id, githubToken() as String
        }
    }
}

/**
 * Getting the change log between the build to promote and the last promoted one
 */
task ontrackChangeLog << {
    // Gets the branch ID
    def http = new HTTPBuilder("${ontrackUrl}/structure/entity/branch/${ontrackProject}/${ontrackBranch()}")
    def branchId = http.get(contentType: ContentType.JSON).id
    println "Branch ${ontrackBranch()} has ID ${branchId}"
    // Gets the change log
    http = new HTTPBuilder("${ontrackUrl}/structure/branches/${branchId}/view/net.nemerosa.ontrack.service.StandardBuildFilterProvider?afterDate=&beforeDate=&count=100&sincePromotionLevel=RELEASE")
    def branchBuildView = http.get(contentType: ContentType.JSON)
    // Boundaries
    def lastBuildId = branchBuildView.buildViews[0].build.id
    def lastReleaseBuildId = branchBuildView.buildViews[branchBuildView.buildViews.size() - 1].build.id
    println "Getting the change log from ${lastReleaseBuildId} to ${lastBuildId}"
    // Exports the change log
    http = new HTTPBuilder("${ontrackUrl}/extension/git/changelog/export?branch=${branchId}&from=${lastBuildId}&to=${lastReleaseBuildId}&format=text&grouping=Features%3Dfeature%7CEnhancements%3Denhancement%7CBugs%3Dbug&exclude=delivery,design")
    def notes = http.get(contentType: ContentType.TEXT).text
    println "Release notes:\n${notes}"
    ext.notes = notes
}

/**
 * Promoting the build in ontrack @ ontrack
 */
task ontrackPromote << {
    // Gets the build ID from ontrack
    def http = new HTTPBuilder("${ontrackUrl}/structure/entity/build/${ontrackProject}/${ontrackBranch()}/${ontrackBuild()}")
    http.auth.basic ontrackUserName(), ontrackUserPassword()
    def buildId = http.get(contentType: ContentType.JSON).id
    println "Build ${ontrackVersion()} has ID ${buildId}"
    // Gets the promotion level for RELEASE
    http = new HTTPBuilder("${ontrackUrl}/structure/entity/promotionLevel/${ontrackProject}/${ontrackBranch()}/RELEASE")
    http.auth.basic ontrackUserName(), ontrackUserPassword()
    def promotionLevelId = http.get(contentType: ContentType.JSON).id
    println "Promotion level RELEASE has ID ${promotionLevelId}"
    // Promoting the build
    http = new HTTPBuilder("${ontrackUrl}/structure/builds/${buildId}/promotionRun/create")
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = authorizationToken()
        body = [
                promotionLevel: promotionLevelId,
                dateTime      : null,
                description   : 'Promoted by the release script',
                properties    : []
        ]
    }
    println "Build ${ontrackVersion()} is promoted to RELEASE."
}
ontrackPromote.mustRunAfter ontrackChangeLog

/**
 * Setting the change log as a description in GitHub
 */
task githubReleaseDescription(dependsOn: ['githubReleaseCreate', 'ontrackChangeLog']) << {
    int releaseId = project.tasks.githubReleaseCreate.releaseId
    String notes = project.tasks.ontrackChangeLog.notes
    println "Setting the release notes on ${releaseId}..."
    def http = new HTTPBuilder("https://api.github.com/repos/${githubRepository}/releases/${releaseId}")
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = "token ${githubToken()}"
        headers['User-Agent'] = "${githubRepository}"
        body = [
                body: notes
        ]
    }
}

/**
 * Main publication task
 */
task publish(dependsOn: ['githubReleaseCreate', 'githubReleaseAssets', 'ontrackChangeLog', 'ontrackPromote', 'githubReleaseDescription'])

/**
 * Support functions
 */

String authorizationToken() {
    'Basic ' + "${ontrackUserName()}:${ontrackUserPassword()}".toString().bytes.encodeBase64().toString()
}