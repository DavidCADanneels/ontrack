/**
 * Versioning policy.
 *
 * The following information must be collected:
 *      - the full version - will be used for the project's version.
 *      - the base version - version information without the build number
 *      - the build version - the build number
 *      - the commit - the commit for this version
 *      - the source - where the version was computed from
 *      - the source type - tag or branch
 *
 * The way this information is collected depends on the environment:
 *
 * - if not .git information is available, we cannot determine the version:
 *     - base = LOCAL
 *     - build = <none>
 *     - full = LOCAL
 *     - commit = <none>
 *     - source = <none>
 *     - source type = 'local'
 *
 * - from a tag (we want to build from a tag)
 *     - the working copy is associated with a tag
 *     - base = TAG (normalised)
 *     - build = <abbrev. sha1>
 *     - full = TAG
 *     - commit = <sha1>
 *     - source = TAG
 *     - source type = 'tag'
 *
 * - from a branch <b>:
 *     - base = <b> (normalised)
 *     - build = <abbrev. sha1>
 *     - full = <base>-<build>
 *     - commit = <sha1>
 *     - source = <b>
 *     - source type = 'branch'
 */

// Information to collect
def versionBase
def versionBuild
def versionFull
def versionCommit
def versionSource
def versionSourceType

boolean hasGit = project.file('.git').exists()

def normalise(String value) {
    value.replaceAll(/[^A-Za-z0-9\.\-_]/, '-')
}

// No git information
if (!hasGit) {
    versionBase = 'LOCAL'
    versionBuild = ''
    versionFull = 'LOCAL'
    versionCommit = ''
    versionSource = ''
    versionSourceType = 'local'
}

// We can use git
else {
    // Gets the current commit (short hash)
    versionBuild = 'git log -1 --format=%h'.execute().text.trim()
    // Gets the current commit (full hash)
    versionCommit = 'git log -1 --format=%H'.execute().text.trim()
    // Gets the tag info
    def tagInfo = 'git describe --exact-match --tags'.execute().text.trim()
    // Gets the branch info
    def branchName = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()
    // We have a tag info
    if (tagInfo) {
        versionBase = normalise(branchName)
        versionFull = normalise(tagInfo)
        versionSource = tagInfo
        versionSourceType = 'tag'
    }
    // We do not have tag info
    else {
        // Gets the current branch
        versionBase = normalise(branchName)
        versionFull = "${versionBase}-${versionBuild}"
        versionSource = branchName
        // Source type
        int pos = versionSource.indexOf('/')
        if (pos > 0) {
            versionSourceType = versionSource.substring(0, pos)
        } else {
            versionSourceType = versionSource
        }
    }
}

// Storing the version information
project.ext.versionBuild = versionBuild
project.ext.versionBase = versionBase
project.ext.versionFull = versionFull
project.ext.versionCommit = versionCommit
project.ext.versionSource = versionSource
project.ext.versionSourceType = versionSourceType

/**
 * Task to display the version information
 */
task displayVersion << {
    println "ontrack.version.full = ${project.version}"
    println "ontrack.version.base = ${project.versionBase}"
    println "ontrack.version.build = ${project.versionBuild}"
    println "ontrack.version.commit = ${project.versionCommit}"
    println "ontrack.version.source = ${project.versionSource}"
    println "ontrack.version.sourceType = ${project.versionSourceType}"
}

/**
 * Task to write the information down into a `version.properties` file
 */
task writeVersion << {
    project.file('version.properties').text = """\
ONTRACK_VERSION_FULL = ${project.version}
ONTRACK_VERSION_BASE = ${project.versionBase}
ONTRACK_VERSION_BUILD = ${project.versionBuild}
ONTRACK_VERSION_COMMIT = ${project.versionCommit}
ONTRACK_VERSION_SOURCE = ${project.versionSource}
ONTRACK_VERSION_SOURCE_TYPE = ${project.versionSourceType}
"""
}