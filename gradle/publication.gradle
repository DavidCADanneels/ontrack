/**
 * PUBLICATION OF A PACKAGE IN GITHUB
 *
 * See the Wiki at https://github.com/nemerosa/ontrack/wiki/Delivery
 */

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    }
}

import groovyx.net.http.ContentType
import groovyx.net.http.HTTPBuilder
import groovyx.net.http.Method

/**
 * Checking the required properties
 */

def param(String name) {
    if (!hasProperty(name)) throw new GradleException("${name} property must be set.")
    else return properties[name]
}

def githubToken = { param('githubToken') }
def ontrackBuild = { param('ontrackBuild') }
def ontrackUserName = { param('ontrackUserName') }
def ontrackUserPassword = { param('ontrackUserPassword') }
def releasePath = { param('releasePath') }

/**
 * Optional properties
 */

if (!hasProperty('ontrackUrl')) ext { ontrackUrl = 'https://ontrack.nemerosa.net' }
if (!hasProperty('ontrackProject')) ext { ontrackProject = 'ontrack' }
if (!hasProperty('ontrackBranch')) ext { ontrackBranch = '2.0' }
if (!hasProperty('githubRepository')) ext { githubRepository = 'nemerosa/ontrack' }

/**
 * Logging the set-up
 */

//println "ontrack build to publish       : ${ontrackBuild}"
//println "ontrack URL                    : ${ontrackUrl}"
//println "ontrack project                : ${ontrackProject}"
//println "ontrack branch                 : ${ontrackBranch}"
//println "ontrack user name              : ${ontrackUserName}"
//println "ontrack user password          : ${ontrackUserPassword}"
//println "GitHub repository to publish to: ${githubRepository}"
//println "GitHub API token               : <set>"
//println "Path to the release files      : ${releasePath}"

/**
 * Creating a GitHub release
 */
task githubReleaseCreate << {
    def url = "https://api.github.com/repos/${githubRepository}/releases"
    def http = new HTTPBuilder(url)
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = "token ${githubToken()}"
        headers['User-Agent'] = "${githubRepository}"
        body = [
                tag_name  : "${ontrackBuild()}".toString(),
                name      : "v${ontrackBuild()}".toString(),
                prerelease: true
        ]
        response.success = { resp, json ->
            int id = json.id as int
            println "Release v${ontrackBuild()} created with ID = $id"
            project.tasks.githubReleaseCreate.ext.releaseId = id
        }
    }
}

def uploadAsset(File file, String name, int releaseId) {
    def url = "https://uploads.github.com/repos/${githubRepository}/releases/${releaseId}/assets?name=${name}"
    def http = new HTTPBuilder(url)
    http.request(Method.POST) { req ->
        headers['Authorization'] = "token ${githubToken()}"
        headers['User-Agent'] = "${githubRepository}"
        headers['Content-Type'] = 'application/zip'
        send ContentType.BINARY, file.bytes
    }
}

/**
 * Uploading assets to a GitHub release
 */
task githubReleaseAssets(dependsOn: 'githubReleaseCreate') << {
    int id = project.tasks.githubReleaseCreate.releaseId
    File file = new File(releasePath() as String, "${ontrackBuild()}.jar")
    println "Publishing ${file} to release ${ontrackBuild()} ($id)..."
    if (!file.exists()) {
        throw new GradleException("File ${file} cannot be published because it does not exist.")
    } else {
        uploadAsset file, 'ontrack.jar', id
    }
}

/**
 * Getting the change log between the build to promote and the last promoted one
 */
task ontrackChangeLog << {
    // Gets the branch ID
    def http = new HTTPBuilder("${ontrackUrl}/structure/entity/branch/${ontrackProject}/${ontrackBranch}")
    def branchId = http.get(contentType: ContentType.JSON).id
    println "Branch ${ontrackBranch} has ID ${branchId}"
    // Gets the change log
    http = new HTTPBuilder("${ontrackUrl}/structure/branches/${branchId}/view/net.nemerosa.ontrack.service.StandardBuildFilterProvider?afterDate=&beforeDate=&count=100&sincePromotionLevel=RELEASE")
    def branchBuildView = http.get(contentType: ContentType.JSON)
    // URI for the change log
    def changelogUri = branchBuildView.buildDiffActions[0].uri
    // Boundaries
    def lastBuildId = branchBuildView.buildViews[0].build.id
    def lastReleaseBuildId = branchBuildView.buildViews[branchBuildView.buildViews.size() - 1].build.id
    println "Getting the change log from ${lastReleaseBuildId} to ${lastBuildId}"
    // Exports the change log
    http = new HTTPBuilder("${ontrackUrl}/extension/git/changelog/export?branch=${branchId}&from=${lastBuildId}&to=${lastReleaseBuildId}&format=text&grouping=Features%3Dfeature%7CEnhancements%3Denhancement%7CBugs%3Dbug&exclude=delivery,design")
    def notes = http.get(contentType: ContentType.TEXT).text
    println "Release notes:\n${notes}"
    ext.notes = notes
}

/**
 * Promoting the build in ontrack @ ontrack
 */
task ontrackPromote << {
    // Gets the build ID from ontrack
    def http = new HTTPBuilder("${ontrackUrl}/structure/entity/build/${ontrackProject}/${ontrackBranch}/${ontrackBuild()}")
    http.auth.basic ontrackUserName(), ontrackUserPassword()
    def buildId = http.get(contentType: ContentType.JSON).id
    println "Build ${ontrackBuild()} has ID ${buildId}"
    // Gets the promotion level for RELEASE
    http = new HTTPBuilder("${ontrackUrl}/structure/entity/promotionLevel/${ontrackProject}/${ontrackBranch}/RELEASE")
    http.auth.basic ontrackUserName(), ontrackUserPassword()
    def promotionLevelId = http.get(contentType: ContentType.JSON).id
    println "Promotion level RELEASE has ID ${promotionLevelId}"
    // Promoting the build
    http = new HTTPBuilder("${ontrackUrl}/structure/builds/${buildId}/promotionRun/create")
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = authorizationToken()
        body = [
                promotionLevel: promotionLevelId,
                dateTime      : null,
                description   : 'Promoted by the release script',
                properties    : []
        ]
    }
    println "Build ${ontrackBuild()} is promoted to RELEASE."
}
ontrackPromote.mustRunAfter ontrackChangeLog

/**
 * Setting the change log as a description in GitHub
 */
task githubReleaseDescription(dependsOn: ['githubReleaseCreate', 'ontrackChangeLog']) << {
    int releaseId = project.tasks.githubReleaseCreate.releaseId
    String notes = project.tasks.ontrackChangeLog.notes
    println "Setting the release notes on ${releaseId}..."
    def http = new HTTPBuilder("https://api.github.com/repos/${githubRepository}/releases/${releaseId}")
    http.request(Method.POST, ContentType.JSON) { req ->
        headers['Authorization'] = "token ${githubToken()}"
        headers['User-Agent'] = "${githubRepository}"
        body = [
                body: notes
        ]
    }
}

/**
 * Main publication task
 */
task publish(dependsOn: ['githubReleaseCreate', 'githubReleaseAssets', 'ontrackChangeLog', 'ontrackPromote', 'githubReleaseDescription'])

/**
 * Support functions
 */

def String authorizationToken() {
    'Basic ' + "${ontrackUserName()}:${ontrackUserPassword()}".toString().bytes.encodeBase64().toString()
}