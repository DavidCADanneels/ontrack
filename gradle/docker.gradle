import java.util.regex.Pattern

/**
 * Docker tasks
 */

task dockerPrepareEnv(type: Copy, dependsOn: ':ontrack-ui:bootRepackage') {
    from 'ontrack-ui/build/libs'
    include '*.jar'
    into project.file('docker')
    rename '.*', 'ontrack.jar'
}

task dockerBuild(type: Exec, dependsOn: dockerPrepareEnv) {
    executable 'docker'
    args = [
            'build',
            '--tag',
            "nemerosa/ontrack:${versioning.info.full}",
            project.file('docker')
    ]
}

task dockerLatest(type: Exec, dependsOn: dockerBuild) {
    executable 'docker'
    args = [
            'tag',
            '--force',
            "nemerosa/ontrack:${versioning.info.full}",
            "nemerosa/ontrack:latest",
    ]
}

// Link with the build
build.dependsOn dockerLatest

/**
 * Docker start class
 */
class DockerStart extends DefaultTask {

    String image = 'nemerosa/ontrack:latest'

    File mount = project.projectDir.absoluteFile

    String profile = 'prod'

    boolean clean = false

    String publish = ''

    private String cid

    private int port

    /**
     * Utility method to get a published port
     */
    int getPublishedPort (String cid, int port = 8080) {
        new ByteArrayOutputStream().withStream { os ->
            project.exec {
                executable = 'docker'
                args = ['port', cid, port]
                standardOutput = os
            }
            def output = os.toString().trim()
            def m = Pattern.compile(/^.*:(\d+)$/).matcher(output)
            if (m.matches()) {
                m.group(1) as int
            } else {
                throw new GradleException("Cannot parse port from ${output}")
            }
        }
    }

    @TaskAction
    def start() {
        println "[${name}] Starting ${image} with mount at ${mount} for profile ${profile}..."
        // Cleaning any previus data
        if (clean) {
            println "[${name}] Cleaning data in ${mount}..."
            project.delete mount
            project.mkdir mount
        }
        // Port publication
        String portPublication
        if (publish) {
            println "[${name}] Publishing ${publish}..."
            portPublication = "--publish=${publish}"
        } else {
            println "[${name}] Publishing on random ports..."
            portPublication = '--publish-all'
        }
        // Starting the container
        def output = new ByteArrayOutputStream()
        project.exec {
            executable 'docker'
            args 'run', '--detach',
                    "--env=PROFILE=${profile}",
                    portPublication,
                    "--volume=${mount}:/var/ontrack",
                    image
            standardOutput = output
        }
        // Getting the container ID
        this.cid = output.toString().trim()
        println "[${name}] Container ${cid} started"
        // Getting the published port
        this.port = getPublishedPort(this.cid)
        println "[${name}] Application running on port ${port}"
    }

    String getCid() {
        cid
    }
}

/**
 * Docker stop task
 */
class DockerStop extends DefaultTask {

    String startTask

    @TaskAction
    def stop() {
        // Gets the start task
        def task = project.tasks.getByName(startTask) as DockerStart
        // Stopping the container
        println "[${name}] Stopping container at ${task.cid} created by ${startTask}"
        project.exec {
            executable 'docker'
            args 'rm', '--force', '--volumes', task.cid
        }
    }

}

/**
 * CI environment
 */

task ciDockerStart(type: DockerStart) {
    image = "nemerosa/ontrack:latest"
    mount = file('gradle/env/ci')
    profile = 'acceptance'
    clean = true
}

task ciDockerStop(type: DockerStop) {
    startTask = 'ciDockerStart'
}
