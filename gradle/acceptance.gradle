import java.util.regex.Pattern

/**
 * Acceptance tasks
 *
 * Only used to run from a packaged Ontrack application against a running server.
 *
 * For local development testing, running the following tasks is enough:
 *
 * ./gradlew build localAcceptanceTest
 */

/**
 * Base class
 */
abstract class AbstractCDTask extends DefaultTask {

    /**
     * Utility method to get a string from running a process
     */
    String execute(String program, List arguments) {
        return new ByteArrayOutputStream().withStream { os ->
            project.exec {
                executable = program
                args = arguments
                standardOutput = os
            }
            return os.toString().trim()
        }
    }

    /**
     * Utility method to get a string from running a process
     */
    String execute(String program, Object... arguments) {
        return execute(program, arguments as List)
    }

}

/**
 * Docker base class
 */
abstract class AbstractDocker extends AbstractCDTask {

    String machine

    /**
     * Docker command
     */
    String docker(Object... arguments) {
        List<?> list = getDockerConfig()
        list.addAll(arguments as List)
        execute('docker', list)
    }

    /**
     * Utility method to get a published port
     */
    int getPublishedPort (String cid, int port = 443) {
        def output = docker('port', cid, port)
        def m = Pattern.compile(/^.*:(\d+)$/).matcher(output)
        if (m.matches()) {
            m.group(1) as int
        } else {
            throw new GradleException("Cannot parse port from ${output}")
        }
    }

    /**
     * Gets the initial arguments for a Docker command
     */
    List<String> getDockerConfig() {
        if (machine) {
            println "[${name}] Using Docker Machine ${machine}"
            def config = execute('docker-machine', 'config', machine)
            return config.split(' ') as List
        } else {
            return []
        }
    }

}

/**
 * Docker start class
 */
class DockerStart extends AbstractDocker {

    String image = 'nemerosa/ontrack:latest'

    File data

    File conf

    String profile = 'prod'

    boolean exposePort = false

    private String cid

    private int port

    @TaskAction
    def start() {
        // Arguments
        List<String> arguments = getDockerConfig()
        // Logging
        println "[${name}] Starting ${image} for profile ${profile}..."
        // All arguments
        arguments.addAll(['run', '--detach', "--env=PROFILE=${profile}"])
        // Port publication
        String portPublication
        if (exposePort) {
            println "[${name}] Publishing port 443..."
            arguments << "--publish=443:443"
        } else {
            println "[${name}] Publishing on random ports..."
            arguments << '--publish-all'
        }
        // Volumes
        if (data) {
            println "[${name}] Data mount: ${data}"
            arguments << "--volume=${data}:/var/ontrack/data"
        } else {
            println "[${name}] No data mount"
        }
        if (conf) {
            println "[${name}] Conf mount: ${conf}"
            arguments << "--volume=${conf}:/var/ontrack/conf"
        } else {
            println "[${name}] No conf mount"
        }
        // Image to start
        arguments << image
        // Starting the container
        cid = execute('docker', arguments)
        println "[${name}] Container ${cid} started"
        // Getting the published port
        this.port = getPublishedPort(this.cid)
        println "[${name}] Application running on port ${port}"
        project.ext.acceptanceOntrackPort = this.port
    }

    String getCid() {
        cid
    }

    int getPort() {
        port
    }
}

/**
 * Docker stop task
 */
class DockerStop extends AbstractDocker {

    String startTask
    String logFile = 'build/docker.log'

    @TaskAction
    def stop() {
        // Gets the start task
        def task = project.tasks.getByName(startTask) as DockerStart
        // Stopping the container
        println "[${name}] Stopping container at ${task.cid} created by ${startTask}"
        // Arguments
        List<String> arguments = getDockerConfig()
        // Getting all the logs
        println "[${name}] Writing log files of ${task.cid} at ${logFile}..."
        String logs = docker('logs', task.cid)
        def targetFile = project.file(logFile)
        targetFile.parentFile.mkdirs()
        targetFile.text = logs
        // Stopping
        arguments.addAll(['rm', '--force', '--volumes', task.cid])
        project.exec {
            executable 'docker'
            args = arguments
        }
    }

}

/**
 * Launching acceptance tests
 */
class RemoteAcceptanceTest extends DefaultTask {

    boolean disableSsl = false

    String acceptanceContext = 'default'

    String acceptanceJar = project.properties.acceptanceJar

    def acceptanceUrl

    String acceptancePassword = 'admin'

    int acceptanceTimeout = 120

    int acceptanceImplicitWait = 5

    @TaskAction
    def launch() {
        // URL
        String url
        if (!acceptanceUrl) throw new GradleException("acceptanceUrl property is not defined for ${name}")
        else if (acceptanceUrl instanceof Closure) {
            url = acceptanceUrl()
        } else {
            url = acceptanceUrl as String
        }
        // Logging
        println "[${name}] Acceptance library at ${acceptanceJar}"
        println "[${name}] Application at ${url}"
        // Running the tests
        project.exec {
            workingDir project.projectDir
            executable 'java'
            args '-jar', "${acceptanceJar}",
                    "--ontrack.url=${url}",
                    "--ontrack.admin=${acceptancePassword}",
                    "--ontrack.disableSsl=${disableSsl}",
                    "--ontrack.context=${acceptanceContext}",
                    "--ontrack.timeout=${acceptanceTimeout}",
                    "--ontrack.implicitWait=${acceptanceImplicitWait}"
        }
    }
}

/**
 * CI environment
 */

task ciDockerStart(type: DockerStart) {
    image = "nemerosa/ontrack:latest"
    conf = file('gradle/env/ci')
    profile = 'acceptance'
}

task ciDockerStop(type: DockerStop) {
    startTask = 'ciDockerStart'
}

task ciAcceptanceTest(type: RemoteAcceptanceTest) {
    acceptanceUrl = { "https://${project.properties.acceptanceHost}:${ciDockerStart.port}" }
    disableSsl = true
    dependsOn ciDockerStart
    finalizedBy ciDockerStop
}

/**
 * DO environment
 */

class DOSetup extends AbstractCDTask {

    String apiToken
    String dropletName
    String region = 'ams2'
    String size = '512mb'

    private String ip

    @TaskAction
    def setup() {
        // Creates the machine
        project.exec {
            executable 'docker-machine'
            args 'create',
                    '--driver=digitalocean',
                    "--digitalocean-access-token=${apiToken}",
                    "--digitalocean-image=docker",
                    "--digitalocean-region=${region}",
                    "--digitalocean-size=${size}",
                    dropletName
        }
        // Gets its IP
        ip = execute('docker-machine', 'ip', dropletName)
        // Displays the IP
        println "[${name}] Droplet ${dropletName} available at ${ip}"
    }

    String getIp() {
        return ip
    }
}

task doSetup(type: DOSetup) {
    doFirst {
        // Checks the token
        if (!digitalOceanAccessToken) {
            throw new GradleException("Missing digitalOceanAccessToken parameter")
        }
        // Checks the version
        if (!ontrackVersion) {
            throw new GradleException("Missing ontrackVersion parameter")
        }
    }
    apiToken = digitalOceanAccessToken
    dropletName = "ontrack-acceptance-${ontrackVersion}"
}

task doTeardown(type: Exec) {
    executable 'docker-machine'
    args = ['rm', '--force', "ontrack-acceptance-${ontrackVersion}"]
    mustRunAfter 'doDockerStop'
}

task doEnv {
    mustRunAfter doSetup
    doFirst {
        project.exec {
            executable 'docker-machine'
            args = ['ssh', "ontrack-acceptance-${ontrackVersion}", 'mkdir -p /var/ontrack']
        }
        project.exec {
            executable 'docker-machine'
            args = ['scp', '-r', 'gradle/env/ci', "ontrack-acceptance-${ontrackVersion}:/var/ontrack/conf"]
        }
    }
}

task doDockerStart(type: DockerStart) {
    machine = "ontrack-acceptance-${ontrackVersion}"
    exposePort = true
    image = "nemerosa/ontrack:${ontrackVersion}"
    conf = file('/var/ontrack/conf')
    profile = 'acceptance'
    mustRunAfter doEnv
}

task doDockerStop(type: DockerStop) {
    machine = "ontrack-acceptance-${ontrackVersion}"
    startTask = 'doDockerStart'
}

task doAcceptanceTest(type: RemoteAcceptanceTest) {
    acceptanceUrl = { "https://${doSetup.ip}" }
    acceptanceTimeout = 300
    acceptanceImplicitWait = 20
    disableSsl = true
    dependsOn doSetup
    dependsOn doEnv
    dependsOn doDockerStart
    finalizedBy doDockerStop
    finalizedBy doTeardown
}
