import java.util.regex.Pattern

/**
 * Acceptance tasks
 *
 * Only used to run from a packaged Ontrack application against a running server.
 *
 * For local development testing, running the following tasks is enough:
 *
 * ./gradlew build localAcceptanceTest
 */


/**
 * Docker start class
 */
class DockerStart extends DefaultTask {

    String image = 'nemerosa/ontrack:latest'

    File mount = project.projectDir.absoluteFile

    String profile = 'prod'

    boolean clean = false

    String publish = ''

    private String cid

    private int port

    /**
     * Utility method to get a published port
     */
    int getPublishedPort (String cid, int port = 8080) {
        new ByteArrayOutputStream().withStream { os ->
            project.exec {
                executable = 'docker'
                args = ['port', cid, port]
                standardOutput = os
            }
            def output = os.toString().trim()
            def m = Pattern.compile(/^.*:(\d+)$/).matcher(output)
            if (m.matches()) {
                m.group(1) as int
            } else {
                throw new GradleException("Cannot parse port from ${output}")
            }
        }
    }

    @TaskAction
    def start() {
        println "[${name}] Starting ${image} with mount at ${mount} for profile ${profile}..."
        // Cleaning any previus data
        if (clean) {
            println "[${name}] Cleaning data in ${mount}..."
            project.delete mount
            project.mkdir mount
        }
        // Port publication
        String portPublication
        if (publish) {
            println "[${name}] Publishing ${publish}..."
            portPublication = "--publish=${publish}"
        } else {
            println "[${name}] Publishing on random ports..."
            portPublication = '--publish-all'
        }
        // Starting the container
        def output = new ByteArrayOutputStream()
        project.exec {
            executable 'docker'
            args 'run', '--detach',
                    "--env=PROFILE=${profile}",
                    portPublication,
                    "--volume=${mount}:/var/ontrack",
                    image
            standardOutput = output
        }
        // Getting the container ID
        this.cid = output.toString().trim()
        println "[${name}] Container ${cid} started"
        // Getting the published port
        this.port = getPublishedPort(this.cid)
        println "[${name}] Application running on port ${port}"
        project.ext.acceptanceOntrackPort = this.port
    }

    String getCid() {
        cid
    }

    int getPort() {
        port
    }
}

/**
 * Docker stop task
 */
class DockerStop extends DefaultTask {

    String startTask

    @TaskAction
    def stop() {
        // Gets the start task
        def task = project.tasks.getByName(startTask) as DockerStart
        // Stopping the container
        println "[${name}] Stopping container at ${task.cid} created by ${startTask}"
        project.exec {
            executable 'docker'
            args 'rm', '--force', '--volumes', task.cid
        }
    }

}

/**
 * Launching acceptance tests
 */
class RemoteAcceptanceTest extends DefaultTask {

    boolean disableSsl = false

    String acceptanceContext = 'default'

    @TaskAction
    def launch() {
        // Collecting the data
        String acceptanceJar = project.properties.acceptanceJar
        // Fixed URL?
        String applicationUrl
        if (project.hasProperty('acceptanceOntrackUrl')) {
            applicationUrl = project.properties.acceptanceOntrackUrl
        } else {
            // Gets the port
            int applicationPort
            def dockerStart = taskDependencies.getDependencies(this).find { it instanceof DockerStart } as DockerStart
            if (dockerStart) {
                applicationPort = dockerStart.port
            } else {
                applicationPort = project.properties.acceptanceOntrackPort as int
            }
            // Computes the URL
            applicationUrl = "${project.properties.acceptanceOntrackScheme}://${project.properties.acceptanceOntrackHost}:${applicationPort}"
        }
        // Logging
        println "[${name}] Acceptance library at ${acceptanceJar}"
        println "[${name}] Application at ${applicationUrl}"
        // Running the tests
        project.exec {
            workingDir project.projectDir
            executable 'java'
            args '-jar', "${acceptanceJar}",
                    "--ontrack.url=${applicationUrl}",
                    "--ontrack.admin=${project.properties.acceptanceOntrackPassword}",
                    "--ontrack.disableSSL=${disableSsl}",
                    "--ontrack.context=${acceptanceContext}",
                    "--ontrack.timeout=${project.properties.acceptanceTimeout}"
        }
    }
}

/**
 * CI environment
 */

task ciDockerStart(type: DockerStart) {
    image = "nemerosa/ontrack:latest"
    mount = file('gradle/env/ci')
    profile = 'acceptance'
    clean = true
}

task ciDockerStop(type: DockerStop) {
    startTask = 'ciDockerStart'
}

task ciAcceptanceTest(type: RemoteAcceptanceTest) {
    // TODO Self signed certificates can be stored locally and mounted
    disableSsl = true
    dependsOn ciDockerStart
    // TODO Wait to be done at acceptance test level
    // TODO dependsOn remoteAcceptanceTest
    finalizedBy ciDockerStop
}