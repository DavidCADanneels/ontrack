[[architecture]]
=== Architecture

[[architecture-modules]]
==== Modules

[plantuml]
----
include::modules.puml[]
----

NOTE: Not all modules nor links are shown here in order to keep some clarity.
The Gradle build files in the source remain the main source of authority.

Modules are used in _ontrack_ for two purposes:

* isolation
* distribution

We distinguish also between:

* core modules
* extension modules

Extension modules rely on the `extension-support` module to be compiled and
tested. The link between the core modules and the extensions is done through
the `extension-api` module, visible by the two worlds.

Modules like `common`, `json`, `tx` or `client` are purely utilitarian
(actually, they could be extracted from `ontrack` itself).

The main core module is the `model` one, which defines both the API of the
Ontrack services and the domain model.

[[architecture-ui]]
==== UI

[[architecture-ui-resources]]
===== Resources

The UI is realized by REST controllers. They manipulate the _model_ and get
access to it through _services_.

In the end, the controllers return _model_ objects that must be decorated by
links in order to achieve Hateoas.

The controllers are not directly responsible for the decoration of the model
objects as _resources_ (model + links). This is instead the responsibility of
the _resource decorators_.

The _model_ objects are not returned as such, often their content needs to be
filtered out. For example, when getting a list of branches for a project, we
do not want each project to bring along its own copy of the project object.
This is achieved using the _model filtering_ technics.

[[architecture-ui-decorators]]
===== Resource decorators

TODO

[[architecture-model]]
==== Model

include::model.adoc[]

[[architecture-model-filtering]]
==== Model filtering

TODO

[[architecture-jobs]]
==== Jobs

Ontrack makes a heavy use of _jobs_ in order to schedule regular activities,
like:

* SCM indexation (for SVN for example)
* SCM/build synchronisations
* Branch templating synchronisation
* etc.

Services and extensions are responsible for providing Ontrack with the list of
_jobs_ they want to be executed. They do this by implementing the
`JobProvider` interface that simply returns a collection of `JobRegistration`s
to register at startup.

One component can also register a `JobOrchestratorSupplier`, which provides
also a stream of `JobRegistration`s, but is more dynamic since the list
of jobs to register will be determined regularly.

The _job scheduler_ is in charge to collect all _registered jobs_ and to run
them all.

[[architecture-jobs-registration]]
===== Job registration

A `JobRegistration` is the associated of a `Job` and of `Schedule` (run
frequency for the job).

A `Schedule` can be built in several ways:

[source,java]
----
// Registration only, no schedule
Schedule.NONE
// Every 15 minutes, starting now
Schedule.everyMinutes(15)
// Every minute, starting now
Schedule.EVERY_MINUTE
// Every day, starting now
Schedule.EVERY_DAY
// Every 15 minutes, starting after 5 minutes
Schedule.everyMinutes(15).after(5)
----

TIP: see the `Schedule` class for more options.

The `Job` interface must define the unique for the job. A key in unique
within a type within a category.

Typically, the category and the type will be fixed (constants) while the
key will depend on the job parameters and context. For example:

[source,java]
----
JobCategory CATEGORY = JobCategory.of("category").withName("My category");
JobType TYPE = CATEGORT.getType("type").withName("My type");
public JobKey getKey() {
   return TYPE.getKey("my-id")
}
----

The `Job` provides also a description, and the desired state of the job:

* disabled or not - might depend on the job parameters and context. For example,
  the job which synchronizes a branch instance with its template will be disable
  if the branch is disabled
* valid or not - when a job becomes invalid, it is not executed, and will be
  unregistered automatically. For example, a Subversion indexation job might
  become invalid if the associated repository configuration has been deleted.

Finally, of course, the job must provide the task to actually execute:

[source,java]
----
public JobRun getTask() {
   return (JobRunListener listener) -> ...
}
----

The task takes as parameter a `JobRunListener`.

IMPORTANT: All job tasks run with _administrator_ privileges. _Job tasks_ can
throw runtime exceptions - they will be caught by the _job scheduler_ and
displayed in the <<admin-console-jobs, administration console>>.
